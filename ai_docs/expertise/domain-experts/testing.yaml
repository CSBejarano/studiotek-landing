domain_id: testing
display_name: Testing Engineer
version: '1.0'
updated_at: '2026-02-03T16:00:28.244423+00:00'
tasks_handled: 44
success_rate: 1.0
keywords:
  primary:
  - test
  - lint
  - build
  - validation
  - qa
  secondary:
  - eslint
  - typescript
  - responsive
  - parallax
  - playwright
  file_patterns:
  - '**/*.test.ts'
  - '**/*.spec.ts'
  exclude: []
context:
  key_concepts:
  - npm run build para produccion
  - npm run lint para codigo limpio
  - Verificacion visual de componentes
  - Responsive testing en DevTools
  - Parallax scroll con Framer Motion
  - Playwright para E2E testing automatizado
  common_patterns:
  - Build antes de merge
  - Lint check despues de cada cambio
  - Visual inspection para landing pages
  - Verificar animaciones scroll-based
  - Playwright para verificacion automatizada de UI
  anti_patterns:
  - No ignorar errores de lint
  - No saltar verificacion responsive
  - No confiar solo en build - verificar visualmente parallax
  preferred_tools:
  - Bash para npm commands
  - Read para verificar codigo
  - Glob para listar archivos
  - Playwright para E2E visual testing
decisions:
- id: SLT001
  context: Landing page testing strategy
  decision: Visual testing + build validation, no unit tests para MVP
  rationale: Landing es principalmente visual, build catch errores de tipo
  confidence: 0.9
  validated_count: 1
  last_used: '2026-01-13'
  tags:
  - testing
  - strategy
  - landing
- id: SLT002
  context: Lint errors en archivos de ejemplo
  decision: Ignorar errores en .claude/skills/*/examples/ - no son codigo de produccion
  rationale: Ejemplos de documentacion, no afectan el build
  confidence: 0.95
  validated_count: 2
  last_used: '2026-01-26'
  tags:
  - lint
  - examples
  - ignore
- id: SLT003
  context: React 19 setState-in-effect warnings
  decision: Warnings de setState en useEffect para hydration son aceptables
  rationale: Es un patron comun de Next.js para manejar SSR hydration mismatch
  confidence: 0.85
  validated_count: 1
  last_used: '2026-01-26'
  tags:
  - lint
  - react-19
  - hydration
- id: SLT004
  context: Parallax scroll testing strategy
  decision: Verificar implementacion en codigo + visual manual; Framer Motion maneja
    animaciones
  rationale: useScroll y useTransform de Framer Motion son confiables, focus en visual
    check
  confidence: 0.9
  validated_count: 2
  last_used: '2026-01-26'
  tags:
  - parallax
  - framer-motion
  - visual
- id: SLT005
  context: Playwright E2E testing para landing pages
  decision: Usar Playwright headless para verificacion automatizada de componentes
    UI
  rationale: Permite verificar DOM, sticky elements, console errors y tomar screenshots
    de evidencia
  confidence: 0.95
  validated_count: 2
  last_used: '2026-02-02'
  tags:
  - playwright
  - e2e
  - visual
  - automation
- id: SLT006
  context: Multi-viewport testing para secciones con responsive breakpoints
  decision: Usar Playwright con 4 viewports (iPhone SE, iPhone 15, iPad Mini, Desktop)
    para verificar breakpoint md:768px
  rationale: El componente Services usa matchMedia(min-width:768px) para switching
    entre mobile grid y expanding card desktop
  confidence: 0.95
  validated_count: 1
  last_used: '2026-02-02'
  tags:
  - playwright
  - responsive
  - viewport
  - breakpoints
blockers: []
validation_checklist:
  build:
  - 'npm run build: SUCCESS (sin errores)'
  - Output en .next/ generado
  lint:
  - 'npm run lint: 0 errors en codigo del proyecto'
  visual:
  - Hero H1 visible con texto correcto
  - Hero subheadline visible
  - 2 CTAs visibles (primary + secondary)
  - Header fijo con z-50
  - Footer con copyright 2026
  responsive:
  - 'Clases sm: presentes para mobile'
  - 'Clases md: presentes para desktop'
  parallax:
  - Imagen sticky con scale 1 -> 0.85
  - Texto con opacity 0 -> 1 -> 0
  - Seccion Problema con gradiente rojo
  - Seccion Solucion con gradiente azul
  - 'Grid responsive: 1 col mobile, 2 cols desktop'
  playwright:
  - Page Load verificado
  - Hero con 40% en H1
  - ProblemSolutionParallax con sticky elements
  - SocialProof NO presente
  - Benefits section con cards
  - ContactForm con form fields
  - Console sin errores
  - Parallax scroll funciona
  - Booking toggle show/hide date-time pickers (AnimatePresence)
  - Full booking submission flow (lead + calendar event creation)
  - Mobile responsive 375x812 contact form (all fields, no overflow, pickers stacked)
last_validation:
  date: '2026-02-03'
  phase: PHASE6_MOBILE_RESPONSIVE
  result: SUCCESS
  criteria_passed: 22
  criteria_total: 22
  notes: 'Phase 6 Mobile Responsive (375x812 iPhone): ALL TESTS PASSED (22/22)


    Test Results:

    [PASS] Page Load: Page loaded successfully

    [PASS] Hero Section: H1 found with "40%" text

    [PASS] ProblemSolutionParallax: Section found, 2 sticky elements, overflow hidden

    [PASS] SocialProof Removed: NOT FOUND (expected)

    [PASS] Benefits Section: Found with 3 cards

    [PASS] ContactForm Section: Found with form and 9 input fields

    [PASS] Console Errors: No console errors

    [PASS] Parallax Scroll: Sticky elements detected during scroll


    Screenshots captured:

    - evidence/screenshot-initial.png (full page initial)

    - evidence/screenshot-parallax.png (parallax section)

    - evidence/screenshot-final.png (full page after scroll)


    Results JSON: evidence/verification-results.json

    '
final_report:
  date: '2026-01-26T10:35:00Z'
  criteria:
  - id: PAGE_LOAD
    description: Pagina carga sin errores
    status: PASS
    details: localhost:3000 respondiendo HTTP 200, networkidle alcanzado
  - id: HERO
    description: Hero muestra 40% en el titulo
    status: PASS
    details: H1='Automatiza tu negocio con IA y ahorra un 40% en costos operativos'
  - id: PARALLAX
    description: ProblemSolutionParallax renderiza correctamente
    status: PASS
    details: Section bg-slate-950 encontrada, 2 sticky elements, overflow hidden
  - id: SOCIAL_PROOF_REMOVED
    description: SocialProof NO esta presente
    status: PASS
    details: No se encontro elemento con data-testid='social-proof'
  - id: BENEFITS
    description: Benefits section funciona
    status: PASS
    details: 'Section #benefits encontrada con 3 cards'
  - id: CONTACT_FORM
    description: ContactForm funciona
    status: PASS
    details: 'Section #contact con form y 9 campos de input'
  - id: CONSOLE_CLEAN
    description: Consola de Chrome sin errores
    status: PASS
    details: 0 errores de consola capturados
  - id: PARALLAX_SCROLL
    description: Parallax scroll funciona (elementos sticky presentes)
    status: PASS
    details: Sticky elements detectados en posiciones de scroll 500-2500px
learnings:
- text: 'El breakpoint critico para GSAP pin + clip-path en Services es 768px (md),
    controlado por window.matchMedia(''(min-width: 768px)'') en el componente - no
    por CSS media queries sino por JS, lo que significa que el test debe verificar
    el comportamiento del DOM resultante (presencia/ausencia de h-screen class) y
    no las CSS media queries directamente.'
  added_at: '2026-02-02T09:19:29.286338+00:00'
- text: Para testing de scroll-based animations con GSAP ScrollTrigger, verificar
    la estructura DOM (refs presentes, clases aplicadas, h-screen para pinning) es
    mas confiable que intentar simular scroll y medir posiciones, ya que headless
    Playwright no ejecuta GSAP pin de la misma forma que un browser real - el enfoque
    correcto es verificar precondiciones (DOM structure) + postcondiciones (no overflow,
    no console errors).
  added_at: '2026-02-02T09:19:29.286338+00:00'
- text: En multi-viewport testing, usar deviceScaleFactor diferenciado (3x para iPhone,
    2x para iPad, 1x para desktop) produce screenshots mas realistas y permite detectar
    problemas de renderizado que no aparecen con scale factor uniforme. Tambien es
    importante dar waitForTimeout(1500) despues de scroll para que GSAP/animations
    se estabilicen antes de verificar el DOM.
  added_at: '2026-02-02T09:19:29.286338+00:00'
- text: Para ejecutar scripts Playwright desde fuera de node_modules, el script debe
    estar dentro del directorio del proyecto para que Node resuelva import { chromium
    } from 'playwright' correctamente - mover el script al proyecto en lugar de correrlo
    desde /tmp evita el ERR_MODULE_NOT_FOUND.
  added_at: '2026-02-03T13:50:40.671144+00:00'
- text: La verificacion de elementos "que NO deben existir" es tan importante como
    verificar los que si existen - usar page.locator('text=...').count() === 0 como
    assertion negativa es un patron clave para validar que features deprecated fueron
    correctamente eliminadas.
  added_at: '2026-02-03T13:50:40.671144+00:00'
- text: El formulario unificado de ContactForm integra el booking como toggle inline
    (checkbox + AnimatePresence para date/time selectors) en lugar de seccion separada,
    lo cual es un patron UX superior que reduce friction al mantener todo en un unico
    flujo de submission.
  added_at: '2026-02-03T13:50:40.671144+00:00'
- text: Para testear AnimatePresence toggle (checkbox show/hide con height 0->auto),
    usar isVisible() de Playwright es suficiente ya que AnimatePresence con height
    0 y opacity 0 hace que isVisible() retorne false correctamente. Un waitForTimeout
    de 500ms (300ms animation + buffer) es suficiente para esperar la transicion.
  added_at: '2026-02-03T15:00:00+00:00'
- text: Verificar disabled state de selects dependientes (e.g. Hora disabled hasta
    que se seleccione Fecha) con isDisabled() es un patron clave para validar UX de
    formularios con campos condicionales encadenados.
  added_at: '2026-02-03T15:00:00+00:00'
- text: Para testear AnimatePresence toggle (checkbox show/hide con height 0->auto),
    isVisible() de Playwright es suficiente ya que AnimatePresence con height 0 y
    opacity 0 hace que isVisible() retorne false correctamente. Un waitForTimeout(500ms)
    (300ms animation + buffer) basta para esperar la transicion.
  added_at: '2026-02-03T13:54:09.453821+00:00'
- text: Verificar el disabled state de selects dependientes (e.g. "Hora" disabled
    hasta que se seleccione "Fecha") con isDisabled() es un patron clave para validar
    UX de formularios con campos condicionales encadenados.
  added_at: '2026-02-03T13:54:09.453821+00:00'
- text: El ciclo completo de test toggle (hidden -> visible -> hidden) con 3 screenshots
    de evidencia es el patron optimo para validar componentes con AnimatePresence,
    ya que confirma tanto la aparicion como la desaparicion sin residuos en el DOM.
  added_at: '2026-02-03T13:54:09.453821+00:00'
- text: El componente Select de /Users/cristianbejaranomendez/Documents/GitHub/studiotek-landing/components/ui/Select.tsx
    tiene un <option> hardcodeado "Selecciona una opcion" (linea 48) que se duplica
    con los placeholders que ContactForm pasa via props -- esto causa que los selects
    tengan 2 opciones placeholder (la hardcodeada + la del prop), un patron que deberia
    refactorizarse para que el placeholder venga solo de props o solo del componente,
    no ambos.
  added_at: '2026-02-03T13:56:45.505987+00:00'
- text: La API /api/booking/slots integrada con Google Calendar FreeBusy responde
    correctamente con HTTP 200 y filtra slots ocupados -- el gap 12:30-14:30 en los
    resultados confirma que la logica de FreeBusy esta funcionando (detecta eventos
    existentes y excluye esos horarios de los slots disponibles).
  added_at: '2026-02-03T13:56:45.505987+00:00'
- text: 'Para testear selects dependientes (Fecha -> Hora), el patron optimo con Playwright
    es: verificar disabled state inicial -> selectOption con valor -> waitForTimeout(3000)
    para API + render -> verificar enabled state + opciones, interceptando responses
    via page.on(''response'') para confirmar que la API fue llamada sin depender solo
    del DOM.'
  added_at: '2026-02-03T13:56:45.505987+00:00'
- text: Para validar texto de mensajes de exito que son efimeros (5s timeout), capturar
    el texto inmediatamente dentro del waitForSelector callback en vez de hacer un
    segundo query al DOM despues -- el componente ContactForm usa setTimeout(() =>
    setStatus('idle'), 5000) y el state change puede causar race conditions con queries
    subsecuentes al [role="alert"].
  added_at: '2026-02-03T13:59:37.448090+00:00'
- text: 'El flujo sin booking de ContactForm ejecuta 2 API calls secuenciales: POST
    /api/leads (await, sincrono) + POST /api/send-email (fire-and-forget con .catch()),
    y ambas se pudieron interceptar via page.on(''response'') a pesar de que el email
    es fire-and-forget -- esto confirma que Playwright captura todas las network responses
    independientemente de si el codigo hace await o no.'
  added_at: '2026-02-03T13:59:37.448090+00:00'
- text: La verificacion de que el formulario se resetea requiere esperar los 5 segundos
    completos del setTimeout + un buffer, ya que durante el estado success el formulario
    esta condicionalmente oculto (status !== 'success') y no se pueden verificar los
    campos vacios hasta que reaparezca.
  added_at: '2026-02-03T13:59:37.448090+00:00'
- text: Para tests E2E de formularios con multiple API calls secuenciales (lead +
    booking), el script debe usar page.waitForResponse() en lugar de page.waitForSelector('[role="alert"]')
    seguido de checks -- el alert DOM puede existir antes de que todas las APIs respondan,
    causando falsos negativos al verificar texto y API calls posteriores.
  added_at: '2026-02-03T14:01:15.355759+00:00'
- text: El flujo de booking submission ejecuta POST /api/leads primero (sincrono,
    await) y luego POST /api/booking/create (tambien sincrono) -- ambas retornan HTTP
    201, y el success message con "Reunion agendada" solo aparece cuando lastSubmitHadBooking
    es true, lo cual requiere que wantsBooking + bookingDate + bookingTime esten todos
    seteados al momento del submit.
  added_at: '2026-02-03T14:01:15.355759+00:00'
- text: La API /api/booking/slots filtra correctamente horarios ocupados via Google
    Calendar FreeBusy -- el gap 12:30-14:30 en los resultados del 2026-02-04 confirma
    que la integracion real con Google Calendar esta funcionando end-to-end en produccion.
  added_at: '2026-02-03T14:01:15.355759+00:00'
- text: 'Para checkboxes controlados por React state (checked={wantsBooking} + onChange),
    Playwright check({ force: true }) falla porque el click no triggers React state
    update -- la solucion es clickear el <label> parent en lugar del <input> directamente,
    ya que el label propaga el evento al onChange handler de React.'
  added_at: '2026-02-03T14:05:02.776940+00:00'
- text: 'La verificacion de layout stacking (vertical vs horizontal) se valida comparando
    getBoundingClientRect() de los dos elementos: si timeRect.top >= dateRect.bottom
    - tolerance, estan en columna; si Math.abs(dateRect.top - timeRect.top) < 10,
    estan side-by-side -- esto es mas confiable que inspeccionar CSS classes porque
    verifica el resultado visual real.'
  added_at: '2026-02-03T14:05:02.776940+00:00'
- text: Verificar document.documentElement.scrollWidth > clientWidth en dos momentos
    (antes y despues de abrir pickers) es el patron correcto para detectar overflow
    horizontal en tests de responsive, ya que componentes dinamicos (AnimatePresence)
    pueden introducir overflow que no existe en el estado inicial.
  added_at: '2026-02-03T14:05:02.776940+00:00'
